---
title: 游戏寻路方案
date: 2022-01-09 20:40:20 +/-TTTT
categories: [寻路]
tags: [寻路方案]
---

##### Grid
将游戏原始地图分割成网格，数据结构表现为二维数组，用0和1分别标识格子是否可走，没有地图的高度信息，因此比较适合2d地图，例如战棋类游戏
  * 优点：容易动态修改地图的某个格子是否可走。算法可以多选，A\*和JPS都支持
  * 缺点：内存占用比较大，格子越小寻路的精确越高，同时占用的内存也会更大。
  
高度图实现3d地图寻路：
 * 客户端在unity里根据navmesh，生成每0.5米一个高度点的高度图给服务器用，可以有多层高度（例如拱桥）
 * 服务器通过高度图，对落差超过一定值的相邻两个格子设置为不可走，这样得出一个可走图，用可走图来做寻路，如果是有多层高度，任意一个高度满足可走，则标识为可走。
 * 服务端是可以分别站在落差比较大的两个相邻格子上（高度图上）的，但是可走图上是标识为不可走的格子，所以开始的时候判断一下起始点和终点，如果是不可走的位置则需要判定一下周围最近可走格为新的寻路起始点或终点
 * ![grid](https://github.com/HahahaVal/HahahaVal.github.io/blob/main/_posts/src/%E5%AF%BB%E8%B7%AF%E6%96%B9%E6%A1%88/grid.png?raw=true)

优化：
 * 因为网格是以一个格子为单位，因此会以红色那条路线移动，实际上当AB中间不存在障碍物时，应该以黑色的路线移动会更自然，因此在寻路前先判断两点之间是否有障碍物，若两点之间无障碍则无需寻路。
 * ![barrier](https://github.com/HahahaVal/HahahaVal.github.io/blob/main/_posts/src/%E5%AF%BB%E8%B7%AF%E6%96%B9%E6%A1%88/barrier.png?raw=true)

* * *

##### WayPoint
在地图编辑器中直接标记一些路点，路点之间不能存在障碍，寻路只能在这些已知的路线进行，因此比较适合NPC固定路线移动。
 * 优点：占用极少的内存和计算消耗
 * 缺点：每张地图都需要人工去编辑复杂的路点，工作量大。
 * ![wayPoint](https://github.com/HahahaVal/HahahaVal.github.io/blob/main/_posts/src/%E5%AF%BB%E8%B7%AF%E6%96%B9%E6%A1%88/way.png?raw=true)

* * *

##### Recastnavigation [源码](https://github.com/recastnavigation/recastnavigation)
导航网格是由多个poly组成，同一个poly中的两点在忽略高度的情况下是可以直达的，而两点位于不同的poly，则利用导航网格配合A\*算法得到经过的poly，再算出具体路径，同时引入了地图高度，比较适合3d地图。
 * 优点：更为精准表达地图，poly会比grid数量少，占用的内存会少
 * 缺点：unity的navmesh可以导出寻路网格，但是和recastnavigation库不完全兼容，因此可以采用第三方插件导出寻路网格[第三方插件](https://github.com/kbengine/unity3d_nav_critterai)
 * ![recastnavigation](https://github.com/HahahaVal/HahahaVal.github.io/blob/main/_posts/src/%E5%AF%BB%E8%B7%AF%E6%96%B9%E6%A1%88/nav.jpg?raw=true)
 
* * *

##### 地图数据处理
 * 服务端加载的源地图数据需要在多线程内共享并且加锁，避免浪费内存。
 * 调用主体是lua，so库返回包含源数据指针和副本数据指针的userdata，副本数据指针默认指向源数据。
 * 如果需要动态改变地图的格子是否可走，则需要拷贝源地图数据，创建地图数据的副本，并改变副本数据指针的指向，后续的所有操作都基于副本数据，gc时把副本数据清理，源数据常驻。
 * ![data](https://github.com/HahahaVal/HahahaVal.github.io/blob/main/_posts/src/%E5%AF%BB%E8%B7%AF%E6%96%B9%E6%A1%88/data.png?raw=true)
 