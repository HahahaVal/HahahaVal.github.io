<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://hahahaval.github.io/</id><title>HahahaVal</title><subtitle>A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.</subtitle> <updated>2022-11-02T15:46:00+08:00</updated> <author> <name>guojin</name> <uri>https://hahahaval.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://hahahaval.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://hahahaval.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator> <rights> © 2022 guojin </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>战斗集群</title><link href="https://hahahaval.github.io/posts/%E6%88%98%E6%96%97%E9%9B%86%E7%BE%A4/" rel="alternate" type="text/html" title="战斗集群" /><published>2022-06-17T10:40:20+08:00</published> <updated>2022-06-17T10:40:20+08:00</updated> <id>https://hahahaval.github.io/posts/%E6%88%98%E6%96%97%E9%9B%86%E7%BE%A4/</id> <content src="https://hahahaval.github.io/posts/%E6%88%98%E6%96%97%E9%9B%86%E7%BE%A4/" /> <author> <name>guojin</name> </author> <category term="战斗" /> <summary> </summary> </entry> <entry><title>九宫格AOI</title><link href="https://hahahaval.github.io/posts/%E4%B9%9D%E5%AE%AB%E6%A0%BCAOI/" rel="alternate" type="text/html" title="九宫格AOI" /><published>2022-01-24T20:40:20+08:00</published> <updated>2022-06-17T18:13:16+08:00</updated> <id>https://hahahaval.github.io/posts/%E4%B9%9D%E5%AE%AB%E6%A0%BCAOI/</id> <content src="https://hahahaval.github.io/posts/%E4%B9%9D%E5%AE%AB%E6%A0%BCAOI/" /> <author> <name>guojin</name> </author> <category term="场景" /> <summary> 九宫格 把整个场景划分为多个格子，每个格子存储对应坐标范围的对象集合。 数据结构 场景网格使用二维数组（随机访问）存储对应xy坐标的对象链表（频繁插入删除），若地图的规格大小为300*300，一个格子的大小为30，则有10*10个格子。 使用map存储entityId和对象的数据，便于获取对应对象。 对象的视野半径最大为1个格子的大小，但也不能太小，因为需要预留客户端资源加载的时间。 aoi对象只存储entityId和aoi，位置数据，只做视野计算和回调通知，由业务层的对象entity保存兴趣列表和被关注列表。 兴趣列表：进入我AOI范围的实体，我感兴趣的对象集合。 被关注列表：我进入了谁的AOI范围，关注我的对象集合。 对象进入 判定对象node坐标边界，将其插入对应格子的对象链表中，并放入... </summary> </entry> <entry><title>十字链表AOI</title><link href="https://hahahaval.github.io/posts/%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8AOI/" rel="alternate" type="text/html" title="十字链表AOI" /><published>2022-01-18T17:40:20+08:00</published> <updated>2022-01-25T10:42:42+08:00</updated> <id>https://hahahaval.github.io/posts/%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8AOI/</id> <content src="https://hahahaval.github.io/posts/%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8AOI/" /> <author> <name>guojin</name> </author> <category term="场景" /> <summary> 十字链表 根据2d地图坐标系将其分成x轴和y轴两个双向链表，如果是3d地图，则需要多维护一条代表高度的双向链表。对象按照坐标值从小到大相应的排列在相应的坐标轴上面。 数据结构 对象的视野半径必须固定最大视野范围，例如坐标系+/-3，在对象进入，移动，离开时作为遍历xy链表的范围。判断是否在视野范围时，需要分别遍历x、y两轴，再求两轴的交集。 aoi对象只存储entityId和aoi，位置数据，只做视野计算和回调通知，由业务层的对象entity保存兴趣列表和被关注列表。 兴趣列表：进入我AOI范围的实体，我感兴趣的对象集合。 被关注列表：我进入了谁的AOI范围，关注我的对象集合。 对象进入 新增的对象需要根据x坐标和y坐标，遍历对应的链表并找到合适的位置插入。 对象移动 对象移动后若只改... </summary> </entry> <entry><title>Jps寻路算法</title><link href="https://hahahaval.github.io/posts/Jps%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/" rel="alternate" type="text/html" title="Jps寻路算法" /><published>2022-01-17T10:40:20+08:00</published> <updated>2022-01-17T10:40:20+08:00</updated> <id>https://hahahaval.github.io/posts/Jps%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/</id> <content src="https://hahahaval.github.io/posts/Jps%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/" /> <author> <name>guojin</name> </author> <category term="寻路" /> <summary> Jps跳点搜索算法 Astar算法在搜索过程中需要把所有的邻居都检查一遍，并将其可走的节点加入到open_list中。 Jps算法搜索过程中只需要检查必要的邻居，将其满足条件的跳点加入到open_list中。 强迫邻居 节点 n 的8个邻居中有障碍，且 n  的父节点 p 经过n 到达 x 的距离代价比不经过 n 到达 x 的任意路径的距离代价小，则称 x 是 n 的强迫邻居。 筛选邻居节点 只需要判定必要的邻居节点是否可走 当前节点n为起点：除了上下左右节点，若当前节点往斜边节点的方向存在任意一个可走节点，则斜边节点也需要判定。 当前节点n与其父节点p的方向向量为斜向：判定斜向分解的x轴和y轴的下个节点，若x轴或y轴的下个节点任意一个可走，则斜向节点也需要判定，若存在强迫邻居节点也需要判定。 当前节点n与其父节点p的方向向量为x轴：判定... </summary> </entry> <entry><title>Astar寻路算法</title><link href="https://hahahaval.github.io/posts/Astar%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/" rel="alternate" type="text/html" title="Astar寻路算法" /><published>2022-01-12T10:40:20+08:00</published> <updated>2022-01-14T10:58:20+08:00</updated> <id>https://hahahaval.github.io/posts/Astar%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/</id> <content src="https://hahahaval.github.io/posts/Astar%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/" /> <author> <name>guojin</name> </author> <category term="寻路" /> <summary> 曼哈顿距离 图形中只允许朝上下左右四个方向移动 计算公式：设格子的单位长度为D (|A.x-B.x|+|A.y-B.y|)*D 欧几里得距离 图形中允许朝任何方向移动 计算公式：根据勾股定理求斜边。设格子的单位长度为D dx=|A.x-B.x| dy=|A.y-B.y| Dsqrt(dxdx+dy*dy) 对角线距离 图形中允许朝八个方向移动 计算公式：设格子的单位长度为D，那么斜向移动一单位距离，根据勾股定理，求腰为D的等腰直角三角形的斜边，即√2D。 dx=|A.x-B.x| dy=|A.y-B.y| D*(dx+dy)+(√2D-2D)*min(dx,dy) 计算机处理浮点数比较耗费资源，可以在损失一定精度的情况下进行优化。√2≈1.4，假设D=10，则√2D≈14，将浮点数转换成整数计算 A*算法 估算公式： f(n... </summary> </entry> </feed>
